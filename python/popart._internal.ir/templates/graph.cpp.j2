// Copyright (c) 2021 Graphcore Ltd. All rights reserved.
/*
 * THIS IS AN AUTOGENERATED FILE, DO NOT EDIT DIRECTLY
 *
 */
#include "bindings/op.hpp"
#include "bindings/graph.hpp"
#include <popart/graph.hpp>
#include <popart/tensorinfo.hpp>

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <vector>

{% for data in metadatas %}
{%- if data['ops']|length > 0 %}
#include <{{data['ops'][0]["file"].lower().replace('willow/include/', '')}}>
{%- endif %}
{%- endfor %}

namespace popart {
namespace _internal {
namespace ir {

void bindCreateOpFunctionToGraphClass(py::class_<Graph> g) {
  {%- for data in metadatas %}
  {%- for op in data['ops'] %}
  // {{ op['name'] }}
  g
  {%- if op["constructors"]|length == 1 -%}
  {#- Single constructor -#}

    .def("createOp_{{op["name"]}}", &Graph::createOp<{{op["name"]}}, {{op["constructors"][-1]["full_args"]}}>,
    {% for arg in op["constructors"][-1]["args"] -%}
     py::arg("
        {%- if arg["arg_name"]|length > 0 -%}
        {{arg["arg_name"]}}
        {%- else -%}
        {{arg["alt_arg_name"]}}
        {%- endif %}"),
    {%- endfor -%}
     py::return_value_policy::reference)

  {%- else -%}
  {#- Multiple constructors using py::overload_cast -#}
  {%- for ctor in op["constructors"] -%}

    .def("createOp_{{op["name"]}}", py::overload_cast<{{ctor["full_args"]}}>(&Graph::createOp<{{op["name"]}}, {{ctor["full_args"]}}>), 
    {% for arg in ctor["args"] -%}
     py::arg("
        {%- if arg["arg_name"]|length > 0 -%}
        {{arg["arg_name"]}}
        {%- else -%}
        {{arg["alt_arg_name"]}}
        {%- endif %}"),
    {%- endfor -%}
    py::return_value_policy::reference)

  {%- endfor -%}
  {% endif %};

  {% endfor %}
  {% endfor %}
}

void bindCreateConnectedOpFunctionToGraphClass(py::class_<Graph> g) {
  {%- for data in metadatas %}
  {%- for op in data['ops'] %}
  // {{ op['name'] }}
  g
  {%- if op["constructors"]|length == 1 -%}
  {#- Single constructor -#}

    .def("createConnectedOp_{{op["name"]}}", &Graph::createConnectedOp<{{op["name"]}}, {{op["constructors"][-1]["full_args"]}}>, 
    py::arg("in") ,
    py::arg("out"),
    {% for arg in op["constructors"][-1]["args"] %}
     py::arg("
        {%- if arg["arg_name"]|length > 0 -%}
        {{arg["arg_name"]}}
        {%- else -%}
        {{arg["alt_arg_name"]}}
        {%- endif %}"),
    {%- endfor -%}
    py::return_value_policy::reference)

  {%- else -%}
  {#- Multiple constructors using py::overload_cast -#}
  {%- for ctor in op["constructors"] -%}

    .def("createConnectedOp_{{op["name"]}}", py::overload_cast<const std::map<InIndex, TensorId> &, const std::map<OutIndex, TensorId> &, {{ctor["full_args"]}}>(&Graph::createConnectedOp<{{op["name"]}}, {{ctor["full_args"]}}>),
    py::arg("in") ,
    py::arg("out"),
    {% for arg in ctor["args"] -%}
     py::arg("
        {%- if arg["arg_name"]|length > 0 -%}
        {{arg["arg_name"]}}
        {%- else -%}
        {{arg["alt_arg_name"]}}
        {%- endif %}"),
    {%- endfor -%}
     py::return_value_policy::reference)

  {%- endfor -%}
  {% endif %};

  {% endfor %}
  {% endfor %}
}

} // namespace ir
} // namespace _internal
} // namespace popart
